# 📘 MSA 개발을 위한 사전 설명 문서

## 2일차 – 개념 이해

**날짜: 6월 17일 (월요일)**

---

## 1️⃣ 모놀리식의 장점(왜 많이 쓰였나)

모놀리식은 **“나쁜 구조”가 아니라, 초기에는 가장 현실적인 구조**입니다.
특히 MVP/PoC/초기 서비스에서는 다음 장점이 큽니다.

### ✅ 1) 개발이 빠르고 단순하다

* 코드가 한 곳에 있어 **개발·디버깅·테스트 흐름이 직관적**
* IDE 한 개, 프로젝트 한 개로 시작 가능
* 신규 인력이 온보딩하기 상대적으로 쉬움

### ✅ 2) 배포와 운영이 단순하다

* 배포 단위가 하나라서 **릴리즈 절차가 단순**
* 서버/네트워크 구성도 단순
* 모니터링 포인트가 적어 초기 운영 부담이 낮음

### ✅ 3) 성능이 유리한 경우가 많다(초기)

* 내부 호출이 **프로세스 내부 함수 호출**이라 네트워크 비용이 없음
* 트랜잭션 처리도 한 DB 중심으로 설계하기 쉬움

### ✅ 4) 데이터 일관성을 유지하기 쉽다

* 한 DB(또는 한 트랜잭션 컨텍스트)로 묶기 쉬워
* “한 번에 처리”가 가능해 보이며 설계가 단순해짐

---

## 2️⃣ 모놀리식의 한계(언제부터 문제가 되나)

시스템이 커질수록 모놀리식의 장점은 **운영 리스크**로 바뀝니다.

### ❌ 1) 변경 영향 범위가 커진다

* 작은 기능 수정도 전체 빌드/배포가 필요
* 테스트 범위가 커지고 배포 리스크가 증가
* “한 기능 배포가 전체 배포”가 됨

### ❌ 2) 확장이 비효율적이다

* 특정 기능만 트래픽이 늘어도
  ➜ **전체 애플리케이션을 함께 확장**
* 비용 증가 + 리소스 낭비가 발생

### ❌ 3) 장애가 전체로 전파된다

* 한 모듈의 오류가 전체 프로세스를 불안정하게 만들 수 있음
* 장애 격리가 어려워 “부분 장애”가 “전체 장애”로 커지기 쉬움

### ❌ 4) 코드베이스가 거대해지고 팀 생산성이 떨어진다

* 빌드 시간 증가, 배포 조율 증가
* 코드 충돌/의존성 얽힘(스파게티화) 증가
* 여러 팀이 한 저장소/한 릴리즈에 얽히며 속도가 느려짐

### ❌ 5) 기술 스택 유연성이 떨어진다

* 한 시스템 안에서 프레임워크/언어/라이브러리 교체가 어려움
* 특정 모듈만 새로운 기술로 갈아타기 힘듦

---

## 3️⃣ “언제” 모놀리식이 문제가 되는가 (현실 기준)

아래 신호가 보이기 시작하면, 구조적 전환을 고민할 타이밍입니다.

### 🚨 신호 A: 배포가 무서워진다

* “이번 배포는 새벽에 해야 안전하다”
* “작은 수정인데도 전체 장애가 걱정된다”
* 배포 빈도가 줄고, 릴리즈가 느려짐

### 🚨 신호 B: 특정 기능이 전체를 끌고 간다

* 특정 API/기능 때문에 CPU/DB가 치솟음
* 그 기능만 확장하고 싶은데 전체를 늘려야 함

### 🚨 신호 C: 장애가 ‘연쇄’로 난다

* 한 기능의 타임아웃/슬로우가 전체 요청을 느리게 함
* DB 락/커넥션 고갈이 전체 서비스 장애로 이어짐

### 🚨 신호 D: 팀이 커질수록 속도가 느려진다

* 팀이 늘어났는데 개발 속도는 빨라지지 않음
* “릴리즈 조율”이 개발보다 더 큰 일이 됨

### 🚨 신호 E: 운영/관측이 어려워진다

* 문제가 생겼는데 “어디서” 발생했는지 파악이 느림
* 로그/모니터링 포인트가 많아져도 원인 추적이 어려움

---

## 4️⃣ 결론: 모놀리식은 ‘단계’다

모놀리식은 많은 시스템의 정상적인 출발점입니다.

다만 서비스가 성장하면
**“단순함”이 “결합도”로 바뀌고**
그 결합도가 다음을 만들기 시작합니다.

* 배포 리스크 증가
* 확장 비효율
* 장애 전파
* 팀 생산성 저하

👉 이 지점에서 MSA 논의가 자연스럽게 시작됩니다.

---

## ✅ 오늘의 핵심 요약

* 모놀리식은 **초기 개발/운영이 단순**해서 강력하다.
* 성장하면 **배포·확장·장애·조직 측면에서 한계**가 급격히 커진다.
* “배포가 무서워지고, 특정 기능이 전체를 끌고 가며, 장애가 연쇄로 나면”
  ➜ 전환을 고민할 시점이다.

---
