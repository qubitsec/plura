# 필상 시스템 — Day 55 Meta-DB(PostgreSQL) 운영 표준: 스키마·인덱스·파티셔닝 · RLS · PITR/백업

1. **날짜**

* 2024-10-28

2. **목표**

* **테넌트/리전 분리 전제의 Postgres 메타-DB**에 대해 **스키마 설계·RLS·인덱스/파티션·PITR 복구** 표준 확정
* **SLO 중심**으로 **지연 p95 ≤ 20ms**, **RPO ≤ 5분**, **RTO ≤ 30분** 달성

---

3. **내용**

### A. 논리 구조 & 멀티테넌시

* **스키마 방식**: 리전별 인스턴스, 테넌트는 **schema per tenant**(소형) 또는 **shared schema + tenant_id 컬럼**(대형).
* **핵심 테이블**

  * `tenants(id, region, plan, status, created_at)` (PK: `id`)
  * `pipelines(id, tenant_id, source, status, created_at)` (PK: `id`, FK: `tenant_id`)
  * `incidents(id, tenant_id, severity, state, created_at, updated_at)` (PK: `id`, BTREE on `(tenant_id, created_at desc)`)
* **RLS 정책(필수)**

  ```sql
  ALTER TABLE incidents ENABLE ROW LEVEL SECURITY;
  CREATE POLICY p_incidents_tenant
  ON incidents USING (tenant_id = current_setting('app.tenant_id')::text);
  -- 게이트웨이가 세션 시작 시: SELECT set_config('app.tenant_id', $tenant, true);
  ```

### B. 인덱스/파티셔닝 표준

* **인덱스 규칙**

  * 시간축 조회: `(tenant_id, created_at desc)` BTREE, 상태 필터가 잦으면 `(tenant_id, state, created_at desc)`
  * 검색 키: `incident_key`, `rule_id`는 BTREE/Hash 혼용 금지 → BTREE 통일
  * **커버링**: 자주 쓰는 목록용 컬럼은 `INCLUDE(severity,state)`
* **파티셔닝**

  * `incidents`·`audit_events`는 **월별 RANGE(created_at)** + **서브파티션 LIST(tenant_id hash 8)**
  * **메인터넌스**: 월말 3일 전 **미리 파티션 생성** / 180일 지난 파티션은 아카이브/드롭 정책
* **자동 Vacuum/Analyze**

  * `autovacuum_vacuum_scale_factor=0.05`, `autovacuum_analyze_scale_factor=0.02`
  * 대형 테이블은 **표준 Fillfactor 80** + 주간 Reindex(병목 시)

### C. 트랜잭션·동시성 가드

* **표준 격리수준**: `READ COMMITTED`(기본), 재시도 가능한 경량 갱신은 **낙관적 잠금(version)**

  ```sql
  ALTER TABLE incidents ADD COLUMN row_ver bigint NOT NULL DEFAULT 0;
  UPDATE incidents SET state='in_progress', row_ver=row_ver+1
  WHERE id=$1 AND row_ver=$2;
  ```
* **대량 삽입**: COPY + 파티션 대상 직접 지정, `synchronous_commit=off`(배치) 옵션 고려
* **Idempotency**: 멱등 키(ULID)로 `INSERT ... ON CONFLICT DO NOTHING` 표준화

### D. 백업·복구(PITR) & 고가용

* **WAL 보존**: `wal_level=replica`, `archive_mode=on`, `archive_timeout=60s`
* **PITR**: 시간별 베이스백업 + WAL 아카이브(보존 14일), **복구 체크리스트**

  1. 타겟 타임스탬프/LSN 확인 → `recovery.conf`(standby.signal) 작성
  2. 복구 완료 후 `SELECT pg_is_in_recovery()`=false 확인
* **HA**: 동기 레플리카 1대(동일 리전), 비동기 세컨더리 1대(읽기), 자동 페일오버(Patroni/pg_auto_failover)
* **복구 검증**: 합성 트랜잭션(계정 생성→티켓 생성→조회) 5분 내 통과해야 **서비스 전환**

### E. 보안·컴플라이언스

* **접속 경로**: 전 구간 mTLS, 운영자 접근은 **Bastion + JIT/JEA**
* **암호화**: TDE(CSP) 가능 시 활성, 최소 **컬럼 레벨 암호화**(P0 필드)
* **감사**: DDL/권한 변경/슈퍼유저 쿼리는 **pgaudit** 별도 테이블 + 해시체인 인덱싱
* **주권**: 백업/WAL은 **리전 내** 버전드 스토리지(WORM) 저장

### F. 성능 SLO & 모니터링

* **SLO(월간)**: 읽기 p95 ≤ **20ms**, 쓰기 p95 ≤ **40ms**, 에러율 < **0.5%**
* **지표**: `xact_commit/rollback`, `locks_waiting`, `checkpoint_timed`, `replication_lag`, `bloat_ratio`, `autovacuum_work`.
* **알람**

  * `replication_lag > 300s` (동기) → **ALERT**
  * `bloat_ratio > 25%` or `dead_tup_ratio > 10%` 1h 지속 → **T1**
  * `conflicts/cancelled by conflict` 증가 → 인덱스/쿼리/파티션 검토

### G. 운영·IaC·마이그레이션

* **마이그 툴**: `sqitch` 또는 `liquibase`(DDL 승인 2인)
* **EMC 절차 연동**: Expand(컬럼 추가) → Migrate(백필/dual-write) → Contract(구컬럼 삭제)
* **롤백**: DDL은 **reversible** 스크립트 필수, 대규모 DDL은 **pg_repack/CONCURRENTLY** 사용
* **테스트**: 스테이징 리플레이(최근 7일 트래픽) + 성능 스모크(p95 ≤ 20/40ms)

### H. API/운영 인터페이스(발췌)

* `POST /v1/meta/tenant {id, region, plan}` — 트랜잭션 생성+RLS 초기화
* `POST /v1/meta/migrate {rev}` — 마이그레이션 적용(검증/승인 포함)
* `GET  /v1/meta/health` — 레플리케이션 지연/Autovacuum/블로트 리포트
* `POST /v1/meta/pitr {timestamp}` — PITR 테스트 복구(샌드박스), 성공 시 리포트 발행

---

4. **예시 설명 (KR 레플리카 지연 9분 → 24분 내 정상화)**

1) 모니터링에서 `replication_lag=540s` 감지, **ALERT** 발생.
2) 확인: `autovacuum` 긴 러닝 + 대형 파티션 인덱스 블로트 32% → 읽기 레플리카가 체크포인트 지연.
3) 조치: 레플리카 `hot_standby_feedback=on` 일시 적용, 문제 파티션에 `REINDEX CONCURRENTLY`, `vacuum_cost_limit` 상향.
4) 18분 내 지연 40s로 회복, 24분에 정상(≤10s). 이후 월말 파티션 **사전 생성/재색인 런북** 갱신.
   → 결과: **RLS·파티션·PITR·모니터링** 표준을 통해 **지연/복구 SLO**를 준수하고, 멀티테넌시 메타-DB의 안정성을 지속 보장.
