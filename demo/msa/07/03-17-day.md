# MSA 개발을 위한 사전 설명 문서

## 17일차 – 컨테이너 입문

**날짜: 7월 3일**

---

## 주제

# **17. 이미지(Image) · 컨테이너(Container) · 레지스트리(Registry)**

> “컨테이너 운영은 결국 ‘이미지의 생명주기’를 관리하는 일이다”

---

## 1️⃣ 한 문장 정의(가장 중요)

* **이미지(Image)**: 실행 환경을 담아 둔 **템플릿(정적)**
* **컨테이너(Container)**: 이미지를 실행한 **실체(동적)**
* **레지스트리(Registry)**: 이미지를 저장·배포하는 **저장소**

---

## 2️⃣ 이미지(Image)란 무엇인가

이미지는 “실행 패키지”입니다.

* 애플리케이션 실행 파일
* 라이브러리/런타임
* 기본 설정
* (필요 시) 빌드된 산출물

즉,

> **이미지는 배포 가능한 결과물(artifact)** 입니다.

### ✅ 이미지의 중요한 특성

* **불변(Immutable)** 로 다루는 것이 원칙
  → 운영 중에 이미지 내부를 수정하지 않음
  → 수정이 필요하면 **새 이미지 버전**을 만듦

---

## 3️⃣ 컨테이너(Container)란 무엇인가

컨테이너는 이미지를 실행한 “프로세스 단위 실행 환경”입니다.

* 컨테이너는 실행/중지/삭제가 매우 빠름
* 죽으면 다시 만들면 됨(재생성)
* 상태는 가능하면 외부로 분리

핵심

> **컨테이너는 소모품(Cattle), 서버는 애완동물(Pet)이 아니다**

---

## 4️⃣ 이미지와 컨테이너의 관계 (비유)

* 이미지 = **설계도**
* 컨테이너 = **설계도로 만든 건물**

설계도(이미지)가 같으면
컨테이너는 어디서든 동일하게 실행될 수 있습니다.

---

## 5️⃣ 레지스트리(Registry)란 무엇인가

레지스트리는 이미지 저장소입니다.

대표 예:

* Docker Hub
* Private Registry
* (클라우드) ECR/GCR/ACR 등

레지스트리가 필요한 이유:

* 여러 서버/노드에서 같은 이미지를 내려받아 실행해야 함
* CI/CD에서 빌드 결과를 저장해야 함
* 버전 관리가 필요함

---

## 6️⃣ 컨테이너 운영의 기본 흐름

MSA 운영에서 가장 기본적인 파이프라인은 아래입니다.

1. 코드 변경
2. 이미지 빌드
3. 레지스트리에 푸시(push)
4. 운영 환경(쿠버네티스 등)에서 풀(pull)
5. 새 컨테이너로 교체 배포

“서버에 접속해서 설치”가 아니라
“이미지 버전을 교체”하는 방식으로 운영합니다.

---

## 7️⃣ 태그(Tag)와 버전 전략(초기 원칙)

이미지는 보통 다음처럼 “태그”로 버전 관리합니다.

* `app:1.0.0`
* `app:1.0.1`
* `app:20250725-01`

원칙(운영 안정성 기준)

* 운영에서는 `latest` 사용을 피하는 편이 안전
* “어떤 코드가 운영 중인지” 태그만 보고 알 수 있어야 함

---

## 8️⃣ 이미지 레이어(Layer) 개념(왜 중요한가)

이미지는 여러 **레이어**로 쌓입니다.

* 변경된 레이어만 다시 빌드/전송 가능
* 캐시로 빌드가 빨라짐
* 동일 레이어를 공유해 디스크 효율이 좋아짐

그래서 Dockerfile 설계가 성능/용량에 영향을 줍니다.

---

## 9️⃣ 흔한 실수 3가지

### 1) 컨테이너 안에 상태 저장

* 컨테이너 삭제 = 데이터 삭제

### 2) 운영에서 latest 태그만 사용

* 롤백/추적 불가능

### 3) “컨테이너에 접속해서” 수정

* 재배포하면 다 사라짐
* 운영 재현 불가

---

## ✅ 오늘의 핵심 요약

* **이미지**는 템플릿, **컨테이너**는 실행 실체, **레지스트리**는 저장소다.
* 운영은 “서버 설치”가 아니라 “이미지 교체”로 한다.
* 이미지는 불변으로 관리하고, 버전(태그)을 명확히 한다.
* 상태는 컨테이너 밖으로 분리하는 것이 기본이다.

---
